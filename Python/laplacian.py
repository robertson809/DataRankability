# Laplacian for directed weighted graphs
# Thomas R. Cameron
# 3/23/2019
import copy
import itertools
import numpy as np

#####################################################################################################################
#                 Spectral Variation Measures                                                                       #
#####################################################################################################################

###############################################
###             eigM                        ###
###############################################
#   Matching distance between spectrum e and s.
###############################################
def eigM(e,s):
    """Matching distance between spectrum e and s."""
    perm = list(itertools.permutations(e))
    return min([max(abs(perm[k]-s)) for k in range(len(perm))])
    
###############################################
###             eigH                       ###
###############################################
#   Hausdorff distance between eigenvalues in e
#   and in s. 
###############################################
def eigH(e,s):
    """Hausdorff distance between eigenvalues in e and in s"""
    def _eigSV(e,s):
        return max([min([abs(e[i]-s[j]) for j in range(len(s))]) for i in range(len(e))])
    return max(_eigSV(e,s),_eigSV(s,e))

# graph Laplacians
lap = [np.array([[5.,-1,-1,-1,-1,-1],[0,3.,-1,0,-1,-1],[0,0,2.,0,-1,-1],[0,-1,-1,4.,-1,-1],[0,0,0,0,1.,-1],[0,0,0,0,0,0.]]),
        np.array([[5.,-1,-1,-1,-1,-1],[0,3.,0,-1,-1,-1],[-1,0,4.,-1,-1,-1],[0,0,0,2.,-1,-1],[0,0,0,0,1.,-1],[0,0,0,0,0,0]]),
        np.array([[3.,-1,0,0,-1,-1],[0,2.,-1,-1,0,0],[0,-1,1.,0,0,0],[-1,0,0,2.,0,-1],[0,0,0,-1,1.,0],[-1,-1,-1,0,-1,4.]]),
        np.array([[3.,-1,-1,-1,0,0],[0,1.,-1,0,0,0],[0,0,0.,0,0,0],[0,0,0,2.,-1,-1],[0,0,0,0,1.,-1],[0,0,0,0,0,0.]]),
        np.array([[2.,-1,0,0,0,-1],[0,2.,-1,-1,0,0],[0,-1,1.,0,0,0],[-1,0,0,2.,0,-1],[0,0,0,0,0.,0],[0,-1,-1,0,0,2.]]),
        np.array([[1.,-1,0,0,0,0],[0,1.,-1,0,0,0],[0,0,1.,-1,0,0],[0,0,0,1.,-1,0],[0,0,0,0,1.,-1],[-1,0,0,0,0,1.]]),
        np.array([[5.,-1,-1,-1,-1,-1],[-1,5.,-1,-1,-1,-1],[-1,-1,5.,-1,-1,-1],[-1,-1,-1,5.,-1,-1],[-1,-1,-1,-1,5.,-1],[-1,-1,-1,-1,-1,5.]]),
        np.zeros((6,6))
        ]
lapN = [np.array([[1,-1/5.,-1/5.,-1/5.,-1/5.,-1/5.],[0,1,-1/3.,0,-1/3.,-1/3.],[0,0,1,0,-1/2.,-1/2.],[0,-1/4.,-1/4.,1,-1/4.,-1/4.],[0,0,0,0,1,-1],[0,0,0,0,0,0]]),
        np.array([[1,-1/5.,-1/5.,-1/5.,-1/5.,-1/5.],[0,1,0,-1/3.,-1/3.,-1/3.],[-1/4.,0,1,-1/4.,-1/4.,-1/4.],[0,0,0,1,-1/2.,-1/2.],[0,0,0,0,1,-1],[0,0,0,0,0,0]]),
        np.array([[1,-1/3.,0,0,-1/3.,-1/3.],[0,1,-1/2.,-1/2.,0,0],[0,-1,1,0,0,0],[-1/2.,0,0,1,0,-1/2.],[0,0,0,-1,1,0],[-1/4.,-1/4.,-1/4.,0,-1/4.,1]]),
        np.array([[1,-1/3.,-1/3.,-1/3.,0,0],[0,1,-1,0,0,0],[0,0,0,0,0,0],[0,0,0,1,-1/2.,-1/2.],[0,0,0,0,1,-1],[0,0,0,0,0,0]]),
        np.array([[1,-1/2.,0,0,0,-1/2.],[0,1,-1/2.,-1/2.,0,0],[0,-1,1,0,0,0],[-1/2.,0,0,1,0,-1/2.],[0,0,0,0,0,0],[0,-1/2.,-1/2.,0,0,1]]),
        np.array([[1,-1.,0,0,0,0],[0,1,-1.,0,0,0],[0,0,1,-1.,0,0],[0,0,0,1,-1.,0],[0,0,0,0,1,-1.],[-1.,0,0,0,0,1]]),
        np.array([[1,-1/5.,-1/5.,-1/5.,-1/5.,-1/5.],[-1/5.,1,-1/5.,-1/5.,-1/5.,-1/5.],[-1/5.,-1/5.,1,-1/5.,-1/5.,-1/5.],[-1/5.,-1/5.,-1/5.,1,-1/5.,-1/5.],[-1/5.,-1/5.,-1/5.,-1/5.,1,-1/5.],[-1/5.,-1/5.,-1/5.,-1/5.,-1/5.,1]]),
        np.zeros((6,6))
        ]
# name of graphs
nam = ['Dominance Graph','Dominance+Perturbation','Perturbed Random Graph','Nearly Disconnected','Random','Cyclic','Completely Connected','Empty Graph']

# eigenvalues of graph Laplacians
e, v = np.linalg.eig(lap[3])
print(e)
print(v)